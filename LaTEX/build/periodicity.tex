\documentclass{article}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}

\title{Anode analysis routine}
\author{Nicolás Sánchez}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
In this document, we explore the periodicity of detected signals in the anodes after the coincidence analysis. The goal is to identify any underlying patterns or periodic behaviour in the data that allow us to better understand the nature of these signals.
\section{Routine}
The analysis is performed using a C++ routine that processes the data from the ROOT files. The routine works as follows:
\begin{itemize}
    \item It reads the data from the ROOT files corresponding to different run numbers.
    \item It applies a threshold to only retain signals with an amplitude above a certain value ($abs(amp)>400$ and $tof>-900$ in our case). We will take into account negative amplitudes in order to see if they correspond to real signals or just noise.
    \item We create a structure to store the relevant information of each signal, namely the run number, BunchNumber, time, psTime, PSPulse, pulse intensity, detector number, time-of-flight and amplitude.
    \item We will also load the PKUP signals, which are stored in another tree in the same ROOT file. We will use these signals to correct the time-of-flight of the anode signals, since they vary because of the different discrimination levels of the DAQs.
    \item The routine then applies a time-of-flight correction to each anode signal based on the corresponding PKUP signal. This is done by finding the PKUP signal with the same beam-related parameters as the anode signal and subtracting its time from the anode signal's time-of-flight.
    \item A sorting algorithm is applied to arrange the signals in a chronological order based on their time stamps. In addition, we also sort the signals with respect to the other variables (except for amplitude and detector number) to facilitate the identification of coincidences, since these value must match between the different signals in order to establish a coincidence.
    \item The routine then identifies coincidences by grouping signals that occur within a specified time window (time\_for\_coincidence = 10 ns in our case). This can be done just by iterating through the sorted list of signals and checking the time difference between one signal and the consecutives. When the time difference is less than the specified window, the signals are in coincidence.
    \item The routine also handles "lonely" signals that do not have any coincidences. This is needed since our algorithm depends on the choice of the first signal to start the coincidence search. To arrange this, we will check every unused signal after the coincidence search and see if it can be merged with any of the already found coincidences. If the time difference between the lonely signal and any signal in a coincidence is less than the specified window, we merge them.
    \item Finally, the routine search for "merged" coincidences, which are groups of signals that correspond to the same event but were not initially identified as such. This is done by checking if any signal in a certain configuration can be in coincidence with any signal in another configuration. If so, we merge the two configurations.
    \item The final configurations of coincidences are then stored in a new ROOT file for further analysis. These output file contains a tree in which each entry corresponds to a coincidences configuration, with branches for the multiplicity of signals (number of hits) in each detector and the amplitude and time-of-flight for each of them. We also store the beam-related information (RunNumber, BunchNumber, etc.). In addition, we also store the total multiplicity (sum of the number of hits in all detectors) in a separate branch.
\end{itemize}   

\section{Analysis}

\subsection{$\gamma$ flash}
The first step in the analysis, in order to see if
 
\end{document}